{"ast":null,"code":"var toString = require('ramda/src/toString');\n\nvar util = require('./internal/util');\n/**\n * A data type that holds a value and exposes a monadic api.\n */\n\n/**\n * Constructs a new `Identity[a]` data type that holds a single\n * value `a`.\n * @param {*} a Value of any type\n * @sig a -> Identity[a]\n */\n\n\nfunction Identity(x) {\n  if (!(this instanceof Identity)) {\n    return new Identity(x);\n  }\n\n  this.value = x;\n}\n\nIdentity.prototype['@@type'] = 'ramda-fantasy/Identity';\n/**\n * Applicative specification. Creates a new `Identity[a]` holding the value `a`.\n * @param {*} a Value of any type\n * @returns Identity[a]\n * @sig a -> Identity[a]\n */\n\nIdentity.of = function (x) {\n  return new Identity(x);\n};\n\nIdentity.prototype.of = Identity.of;\n/**\n * Functor specification. Creates a new `Identity[a]` mapping function `f` onto\n * `a` returning any value b.\n * @param {Function} f Maps `a` to any value `b`\n * @returns Identity[b]\n * @sig @Identity[a] => (a -> b) -> Identity[b]\n */\n\nIdentity.prototype.map = function (f) {\n  return new Identity(f(this.value));\n};\n/**\n * Apply specification. Applies the function inside the `Identity[a]`\n * type to another applicative type.\n * @param {Applicative[a]} app Applicative that will apply its function\n * @returns Applicative[b]\n * @sig (Identity[a -> b], f: Applicative[_]) => f[a] -> f[b]\n */\n\n\nIdentity.prototype.ap = function (app) {\n  return app.map(this.value);\n};\n/**\n * Chain specification. Transforms the value of the `Identity[a]`\n * type using an unary function to monads. The `Identity[a]` type\n * should contain a function, otherwise an error is thrown.\n *\n * @param {Function} fn Transforms `a` into a `Monad[b]`\n * @returns Monad[b]\n * @sig (Identity[a], m: Monad[_]) => (a -> m[b]) -> m[b]\n */\n\n\nIdentity.prototype.chain = function (fn) {\n  return fn(this.value);\n}; // chainRec\n\n\nIdentity.chainRec = Identity.prototype.chainRec = function (f, i) {\n  var state = util.chainRecNext(i);\n\n  while (state.isNext) {\n    state = f(util.chainRecNext, util.chainRecDone, state.value).get();\n  }\n\n  return Identity(state.value);\n};\n/**\n * Returns the value of `Identity[a]`\n *\n * @returns a\n * @sig (Identity[a]) => a\n */\n\n\nIdentity.prototype.get = function () {\n  return this.value;\n}; // equality method to enable testing\n\n\nIdentity.prototype.equals = util.getEquals(Identity);\n\nIdentity.prototype.toString = function () {\n  return 'Identity(' + toString(this.value) + ')';\n};\n\nmodule.exports = Identity;","map":{"version":3,"sources":["/home/noname001/react-typescript-data-gen/node_modules/ramda-fantasy/src/Identity.js"],"names":["toString","require","util","Identity","x","value","prototype","of","map","f","ap","app","chain","fn","chainRec","i","state","chainRecNext","isNext","chainRecDone","get","equals","getEquals","module","exports"],"mappings":"AAAA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,oBAAD,CAAtB;;AAEA,IAAIC,IAAI,GAAGD,OAAO,CAAC,iBAAD,CAAlB;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,QAAT,CAAkBC,CAAlB,EAAqB;AACnB,MAAI,EAAE,gBAAgBD,QAAlB,CAAJ,EAAiC;AAC/B,WAAO,IAAIA,QAAJ,CAAaC,CAAb,CAAP;AACD;;AACD,OAAKC,KAAL,GAAaD,CAAb;AACD;;AAEDD,QAAQ,CAACG,SAAT,CAAmB,QAAnB,IAA+B,wBAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAH,QAAQ,CAACI,EAAT,GAAc,UAASH,CAAT,EAAY;AACxB,SAAO,IAAID,QAAJ,CAAaC,CAAb,CAAP;AACD,CAFD;;AAGAD,QAAQ,CAACG,SAAT,CAAmBC,EAAnB,GAAwBJ,QAAQ,CAACI,EAAjC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAJ,QAAQ,CAACG,SAAT,CAAmBE,GAAnB,GAAyB,UAASC,CAAT,EAAY;AACnC,SAAO,IAAIN,QAAJ,CAAaM,CAAC,CAAC,KAAKJ,KAAN,CAAd,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAF,QAAQ,CAACG,SAAT,CAAmBI,EAAnB,GAAwB,UAASC,GAAT,EAAc;AACpC,SAAOA,GAAG,CAACH,GAAJ,CAAQ,KAAKH,KAAb,CAAP;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAF,QAAQ,CAACG,SAAT,CAAmBM,KAAnB,GAA2B,UAASC,EAAT,EAAa;AACtC,SAAOA,EAAE,CAAC,KAAKR,KAAN,CAAT;AACD,CAFD,C,CAIA;;;AACAF,QAAQ,CAACW,QAAT,GAAoBX,QAAQ,CAACG,SAAT,CAAmBQ,QAAnB,GAA8B,UAASL,CAAT,EAAYM,CAAZ,EAAe;AAC/D,MAAIC,KAAK,GAAGd,IAAI,CAACe,YAAL,CAAkBF,CAAlB,CAAZ;;AACA,SAAOC,KAAK,CAACE,MAAb,EAAqB;AACnBF,IAAAA,KAAK,GAAGP,CAAC,CAACP,IAAI,CAACe,YAAN,EAAoBf,IAAI,CAACiB,YAAzB,EAAuCH,KAAK,CAACX,KAA7C,CAAD,CAAqDe,GAArD,EAAR;AACD;;AACD,SAAOjB,QAAQ,CAACa,KAAK,CAACX,KAAP,CAAf;AACD,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;;;AACAF,QAAQ,CAACG,SAAT,CAAmBc,GAAnB,GAAyB,YAAW;AAClC,SAAO,KAAKf,KAAZ;AACD,CAFD,C,CAIA;;;AACAF,QAAQ,CAACG,SAAT,CAAmBe,MAAnB,GAA4BnB,IAAI,CAACoB,SAAL,CAAenB,QAAf,CAA5B;;AAEAA,QAAQ,CAACG,SAAT,CAAmBN,QAAnB,GAA8B,YAAW;AACvC,SAAO,cAAcA,QAAQ,CAAC,KAAKK,KAAN,CAAtB,GAAqC,GAA5C;AACD,CAFD;;AAIAkB,MAAM,CAACC,OAAP,GAAiBrB,QAAjB","sourcesContent":["var toString = require('ramda/src/toString');\n\nvar util = require('./internal/util');\n\n\n/**\n * A data type that holds a value and exposes a monadic api.\n */\n\n/**\n * Constructs a new `Identity[a]` data type that holds a single\n * value `a`.\n * @param {*} a Value of any type\n * @sig a -> Identity[a]\n */\nfunction Identity(x) {\n  if (!(this instanceof Identity)) {\n    return new Identity(x);\n  }\n  this.value = x;\n}\n\nIdentity.prototype['@@type'] = 'ramda-fantasy/Identity';\n\n/**\n * Applicative specification. Creates a new `Identity[a]` holding the value `a`.\n * @param {*} a Value of any type\n * @returns Identity[a]\n * @sig a -> Identity[a]\n */\nIdentity.of = function(x) {\n  return new Identity(x);\n};\nIdentity.prototype.of = Identity.of;\n\n/**\n * Functor specification. Creates a new `Identity[a]` mapping function `f` onto\n * `a` returning any value b.\n * @param {Function} f Maps `a` to any value `b`\n * @returns Identity[b]\n * @sig @Identity[a] => (a -> b) -> Identity[b]\n */\nIdentity.prototype.map = function(f) {\n  return new Identity(f(this.value));\n};\n\n/**\n * Apply specification. Applies the function inside the `Identity[a]`\n * type to another applicative type.\n * @param {Applicative[a]} app Applicative that will apply its function\n * @returns Applicative[b]\n * @sig (Identity[a -> b], f: Applicative[_]) => f[a] -> f[b]\n */\nIdentity.prototype.ap = function(app) {\n  return app.map(this.value);\n};\n\n/**\n * Chain specification. Transforms the value of the `Identity[a]`\n * type using an unary function to monads. The `Identity[a]` type\n * should contain a function, otherwise an error is thrown.\n *\n * @param {Function} fn Transforms `a` into a `Monad[b]`\n * @returns Monad[b]\n * @sig (Identity[a], m: Monad[_]) => (a -> m[b]) -> m[b]\n */\nIdentity.prototype.chain = function(fn) {\n  return fn(this.value);\n};\n\n// chainRec\nIdentity.chainRec = Identity.prototype.chainRec = function(f, i) {\n  var state = util.chainRecNext(i);\n  while (state.isNext) {\n    state = f(util.chainRecNext, util.chainRecDone, state.value).get();\n  }\n  return Identity(state.value);\n};\n\n/**\n * Returns the value of `Identity[a]`\n *\n * @returns a\n * @sig (Identity[a]) => a\n */\nIdentity.prototype.get = function() {\n  return this.value;\n};\n\n// equality method to enable testing\nIdentity.prototype.equals = util.getEquals(Identity);\n\nIdentity.prototype.toString = function() {\n  return 'Identity(' + toString(this.value) + ')';\n};\n\nmodule.exports = Identity;\n"]},"metadata":{},"sourceType":"script"}