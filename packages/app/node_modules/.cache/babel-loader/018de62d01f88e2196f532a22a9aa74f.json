{"ast":null,"code":"var once = require('ramda/src/once');\n\nvar forEach = require('ramda/src/forEach');\n\nvar toString = require('ramda/src/toString');\n\nvar curry = require('ramda/src/curry');\n\nvar util = require('./internal/util');\n\nfunction jail(handler, f) {\n  return function (a) {\n    try {\n      return f(a);\n    } catch (err) {\n      handler(err);\n    }\n  };\n} // `f` is a function that takes two function arguments: `reject` (failure) and `resolve` (success)\n\n\nfunction Future(f) {\n  if (!(this instanceof Future)) {\n    return new Future(f);\n  }\n\n  this._fork = f;\n}\n\nFuture.prototype['@@type'] = 'ramda-fantasy/Future';\n\nFuture.prototype.fork = function (reject, resolve) {\n  this._fork(reject, jail(reject, resolve));\n}; // functor\n\n\nFuture.prototype.map = function (f) {\n  return this.chain(function (a) {\n    return Future.of(f(a));\n  });\n}; // apply\n\n\nFuture.prototype.ap = function (m) {\n  var self = this;\n  return new Future(function (rej, res) {\n    var applyFn, val;\n    var doReject = once(rej);\n    var resolveIfDone = jail(doReject, function () {\n      if (applyFn != null && val != null) {\n        return res(applyFn(val));\n      }\n    });\n\n    self._fork(doReject, function (fn) {\n      applyFn = fn;\n      resolveIfDone();\n    });\n\n    m._fork(doReject, function (v) {\n      val = v;\n      resolveIfDone();\n    });\n  });\n}; // applicative\n\n\nFuture.of = function (x) {\n  // should include a default rejection?\n  return new Future(function (_, resolve) {\n    return resolve(x);\n  });\n};\n\nFuture.prototype.of = Future.of; // chain\n//  f must be a function which returns a value\n//  f must return a value of the same Chain\n//  chain must return a value of the same Chain\n//:: Future a, b => (b -> Future c) -> Future c\n\nFuture.prototype.chain = function (f) {\n  // Sorella's:\n  return new Future(function (reject, resolve) {\n    return this._fork(function (a) {\n      return reject(a);\n    }, jail(reject, function (b) {\n      return f(b)._fork(reject, resolve);\n    }));\n  }.bind(this));\n}; // chainRec\n//\n// Heavily influenced by the Aff MonadRec instance\n// https://github.com/slamdata/purescript-aff/blob/51106474122d0e5aec8e3d5da5bb66cfe8062f55/src/Control/Monad/Aff.js#L263-L322\n\n\nFuture.chainRec = Future.prototype.chainRec = function (f, a) {\n  return Future(function (reject, resolve) {\n    return function go(acc) {\n      // isSync could be in three possable states\n      // * null - unresolved status\n      // * true - synchronous future\n      // * false - asynchronous future\n      var isSync = null;\n      var state = util.chainRecNext(acc);\n\n      var onResolve = function (v) {\n        // If the `isSync` is still unresolved, we have observed a\n        // synchronous future. Otherwise, `isSync` will be `false`.\n        if (isSync === null) {\n          isSync = true; // Store the result for further synchronous processing.\n\n          state = v;\n        } else {\n          // When we have observed an asynchronous future, we use normal\n          // recursion. This is safe because we will be on a new stack.\n          (v.isNext ? go : resolve)(v.value);\n        }\n      };\n\n      while (state.isNext) {\n        isSync = null;\n        f(util.chainRecNext, util.chainRecDone, state.value).fork(reject, onResolve); // If the `isSync` has already resolved to `true` by our `onResolve`, then\n        // we have observed a synchronous future. Otherwise it will still be `null`.\n\n        if (isSync === true) {\n          continue;\n        } else {\n          // If the status has not resolved yet, then we have observed an\n          // asynchronous or failed future so update status and exit the loop.\n          isSync = false;\n          return;\n        }\n      }\n\n      resolve(state.value);\n    }(a);\n  });\n}; // chainReject\n// Like chain but operates on the reject instead of the resolve case.\n//:: Future a, b => (a -> Future c) -> Future c\n\n\nFuture.prototype.chainReject = function (f) {\n  return new Future(function (reject, resolve) {\n    return this._fork(jail(reject, function (a) {\n      return f(a)._fork(reject, resolve);\n    }), function (b) {\n      return resolve(b);\n    });\n  }.bind(this));\n}; // monad\n// A value that implements the Monad specification must also implement the Applicative and Chain specifications.\n// see above.\n\n\nFuture.prototype.bimap = function (errFn, successFn) {\n  var self = this;\n  return new Future(function (reject, resolve) {\n    self._fork(jail(reject, function (err) {\n      reject(errFn(err));\n    }), jail(reject, function (val) {\n      resolve(successFn(val));\n    }));\n  });\n};\n\nFuture.reject = function (val) {\n  return new Future(function (reject) {\n    reject(val);\n  });\n};\n\nFuture.prototype.toString = function () {\n  return 'Future(' + toString(this._fork) + ')';\n};\n\nFuture.cache = function (f) {\n  var status = 'IDLE';\n  var listeners = [];\n  var cachedValue;\n  var handleCompletion = curry(function (newStatus, cb, val) {\n    status = newStatus;\n    cachedValue = val;\n    cb(val);\n    forEach(function (listener) {\n      listener[status](cachedValue);\n    }, listeners);\n  });\n\n  function addListeners(reject, resolve) {\n    listeners.push({\n      REJECTED: reject,\n      RESOLVED: resolve\n    });\n  }\n\n  function doResolve(reject, resolve) {\n    status = 'PENDING';\n    return f._fork(handleCompletion('REJECTED', reject), handleCompletion('RESOLVED', resolve));\n  }\n\n  return new Future(function (reject, resolve) {\n    switch (status) {\n      case 'IDLE':\n        doResolve(reject, resolve);\n        break;\n\n      case 'PENDING':\n        addListeners(reject, resolve);\n        break;\n\n      case 'REJECTED':\n        reject(cachedValue);\n        break;\n\n      case 'RESOLVED':\n        resolve(cachedValue);\n        break;\n    }\n  });\n};\n\nmodule.exports = Future;","map":{"version":3,"sources":["/home/noname001/react-typescript-data-gen/node_modules/ramda-fantasy/src/Future.js"],"names":["once","require","forEach","toString","curry","util","jail","handler","f","a","err","Future","_fork","prototype","fork","reject","resolve","map","chain","of","ap","m","self","rej","res","applyFn","val","doReject","resolveIfDone","fn","v","x","_","b","bind","chainRec","go","acc","isSync","state","chainRecNext","onResolve","isNext","value","chainRecDone","chainReject","bimap","errFn","successFn","cache","status","listeners","cachedValue","handleCompletion","newStatus","cb","listener","addListeners","push","REJECTED","RESOLVED","doResolve","module","exports"],"mappings":"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","sourcesContent":["var once = require('ramda/src/once');\nvar forEach = require('ramda/src/forEach');\nvar toString = require('ramda/src/toString');\nvar curry = require('ramda/src/curry');\n\nvar util = require('./internal/util');\n\nfunction jail(handler, f){\n  return function(a){\n    try{\n      return f(a);\n    } catch(err) {\n      handler(err);\n    }\n  };\n}\n\n// `f` is a function that takes two function arguments: `reject` (failure) and `resolve` (success)\nfunction Future(f) {\n  if (!(this instanceof Future)) {\n    return new Future(f);\n  }\n  this._fork = f;\n}\n\nFuture.prototype['@@type'] = 'ramda-fantasy/Future';\n\nFuture.prototype.fork = function(reject, resolve) {\n  this._fork(reject, jail(reject, resolve));\n};\n\n// functor\nFuture.prototype.map = function(f) {\n  return this.chain(function(a) { return Future.of(f(a)); });\n};\n\n// apply\nFuture.prototype.ap = function(m) {\n  var self = this;\n\n  return new Future(function(rej, res) {\n    var applyFn, val;\n    var doReject = once(rej);\n\n    var resolveIfDone = jail(doReject, function() {\n      if (applyFn != null && val != null) {\n        return res(applyFn(val));\n      }\n    });\n\n    self._fork(doReject, function(fn) {\n      applyFn = fn;\n      resolveIfDone();\n    });\n\n    m._fork(doReject, function(v) {\n      val = v;\n      resolveIfDone();\n    });\n\n  });\n\n};\n\n// applicative\nFuture.of = function(x) {\n  // should include a default rejection?\n  return new Future(function(_, resolve) { return resolve(x); });\n};\n\nFuture.prototype.of = Future.of;\n\n// chain\n//  f must be a function which returns a value\n//  f must return a value of the same Chain\n//  chain must return a value of the same Chain\n//:: Future a, b => (b -> Future c) -> Future c\nFuture.prototype.chain = function(f) {  // Sorella's:\n  return new Future(function(reject, resolve) {\n    return this._fork(\n      function(a) { return reject(a); },\n      jail(reject, function(b) { return f(b)._fork(reject, resolve); })\n    );\n  }.bind(this));\n};\n\n// chainRec\n//\n// Heavily influenced by the Aff MonadRec instance\n// https://github.com/slamdata/purescript-aff/blob/51106474122d0e5aec8e3d5da5bb66cfe8062f55/src/Control/Monad/Aff.js#L263-L322\nFuture.chainRec = Future.prototype.chainRec = function(f, a) {\n  return Future(function(reject, resolve) {\n    return function go(acc) {\n      // isSync could be in three possable states\n      // * null - unresolved status\n      // * true - synchronous future\n      // * false - asynchronous future\n      var isSync = null;\n      var state = util.chainRecNext(acc);\n      var onResolve = function(v) {\n        // If the `isSync` is still unresolved, we have observed a\n        // synchronous future. Otherwise, `isSync` will be `false`.\n        if (isSync === null) {\n          isSync = true;\n          // Store the result for further synchronous processing.\n          state = v;\n        } else {\n          // When we have observed an asynchronous future, we use normal\n          // recursion. This is safe because we will be on a new stack.\n          (v.isNext ? go : resolve)(v.value);\n        }\n      };\n      while (state.isNext) {\n        isSync = null;\n        f(util.chainRecNext, util.chainRecDone, state.value).fork(reject, onResolve);\n        // If the `isSync` has already resolved to `true` by our `onResolve`, then\n        // we have observed a synchronous future. Otherwise it will still be `null`.\n        if (isSync === true) {\n          continue;\n        } else {\n          // If the status has not resolved yet, then we have observed an\n          // asynchronous or failed future so update status and exit the loop.\n          isSync = false;\n          return;\n        }\n      }\n      resolve(state.value);\n    }(a);\n  });\n};\n\n// chainReject\n// Like chain but operates on the reject instead of the resolve case.\n//:: Future a, b => (a -> Future c) -> Future c\nFuture.prototype.chainReject = function(f) {\n  return new Future(function(reject, resolve) {\n    return this._fork(\n      jail(reject, function(a) { return f(a)._fork(reject, resolve); }),\n      function(b) { return resolve(b); }\n    );\n  }.bind(this));\n};\n\n// monad\n// A value that implements the Monad specification must also implement the Applicative and Chain specifications.\n// see above.\n\nFuture.prototype.bimap = function(errFn, successFn) {\n  var self = this;\n  return new Future(function(reject, resolve) {\n    self._fork(\n      jail(reject, function(err) { reject(errFn(err)); }),\n      jail(reject, function(val) { resolve(successFn(val)); })\n    );\n  });\n};\n\nFuture.reject = function(val) {\n  return new Future(function(reject) {\n    reject(val);\n  });\n};\n\nFuture.prototype.toString = function() {\n  return 'Future(' + toString(this._fork) + ')';\n};\n\nFuture.cache = function(f) {\n  var status = 'IDLE';\n  var listeners = [];\n  var cachedValue;\n\n  var handleCompletion = curry(function(newStatus, cb, val) {\n    status = newStatus;\n    cachedValue = val;\n    cb(val);\n    forEach(function(listener) {\n      listener[status](cachedValue);\n    }, listeners);\n  });\n\n  function addListeners(reject, resolve) {\n    listeners.push({ REJECTED: reject, RESOLVED: resolve } );\n  }\n\n  function doResolve(reject, resolve) {\n    status = 'PENDING';\n    return f._fork(\n      handleCompletion('REJECTED', reject),\n      handleCompletion('RESOLVED', resolve)\n    );\n  }\n\n  return new Future(function(reject, resolve) {\n\n    switch(status) {\n      case 'IDLE': doResolve(reject, resolve); break;\n      case 'PENDING': addListeners(reject, resolve); break;\n      case 'REJECTED': reject(cachedValue); break;\n      case 'RESOLVED': resolve(cachedValue); break;\n    }\n\n  });\n};\n\nmodule.exports = Future;\n"]},"metadata":{},"sourceType":"script"}