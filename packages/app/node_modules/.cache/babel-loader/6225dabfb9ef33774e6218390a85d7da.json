{"ast":null,"code":"import { always, append, assoc, chain, clone, converge, curry, filter, flatten, is, keys, length, map, mergeRight, objOf, of, omit, path, pick, pipe, pluck, prop, propEq, reduce, reject, slice, splitAt, transpose, values, when, zipObj, __ } from 'ramda';\n\n// import {Maybe} from 'ramda-fantasy'\nconst RF = require('ramda-fantasy'),\n      Maybe = RF.Maybe,\n      Just = Maybe.Just,\n      Nothing = Maybe.Nothing; // const seq = sequence(Maybe.of, [Maybe.Just(1), Maybe.Just(2), Maybe.Just(3)])\n// const lenFuncTest = lenFunc(\"string\")\n// lenFunc(\"asdfasf\")\n// export const multipledParts: any = (parts: any[][]) => parts.reduce(<any>xprod)\n//   .map(<any>flatten)\n\n\nimport { multipledParts } from 'ramda-combo';\nexport const sliceAndTranspose = curry((columns, multipled, equalsName) => pipe(filter(equalsName), path([0, 'collect']), converge(append, [clone, pipe(converge(slice(0), [length, always(multipled)]), of)]), transpose)(columns));\n/**\n *   CartesianProduct Non using Ramda\n  const result = parts.reduce((\n    a, b\n  ) => a.reduce(\n    (\n      r, v\n    ) => r.concat(b.map(w => [].concat(\n      v, w\n    ))), []\n  ))\n */\n// TODO: REDUCE ~> one cycle\n\nexport const propFilterAndPluck = (propNameEq, propValue, propPluck) => pipe(reject(propEq(propNameEq, propValue)), pluck(propPluck));\nexport const cartesianCondition = (columns, limiting) => pipe(propFilterAndPluck('name', limiting, 'collect'), multipledParts, when(always(is(String, limiting)), sliceAndTranspose(columns, __, propEq('name', limiting))), map(pipe(flatten, converge(zipObj, [always(pluck('name', columns)), clone]))))(columns);\nexport const enumToObject = pipe(values, converge(splitAt, [pipe(filter(is(Number)), length), clone]), converge(zipObj, [prop(0), prop(1)]));\nexport const renameKeys = curry((keysMap, obj) => reduce((acc, key) => assoc(keysMap[key] || key, obj[key], acc), {}, keys(obj)));\nexport const findAndMerge = curry((els, element, propName) => map(when(propEq(propName, prop(propName, element)), mergeRight(__, element)))(els));\nexport const addParam = curry((name, func, args) => chain(assoc(name), converge(func, args)));\nexport const mergeAndRestruct = curry((columns, wrapper) => converge(mergeRight, [pick(columns), pipe(omit(columns), objOf(wrapper))]));","map":{"version":3,"sources":["/home/noname001/react-typescript-data-gen/packages/app/src/utils/popular.ts"],"names":["always","append","assoc","chain","clone","converge","curry","filter","flatten","is","keys","length","map","mergeRight","objOf","of","omit","path","pick","pipe","pluck","prop","propEq","reduce","reject","slice","splitAt","transpose","values","when","zipObj","__","RF","require","Maybe","Just","Nothing","multipledParts","sliceAndTranspose","columns","multipled","equalsName","propFilterAndPluck","propNameEq","propValue","propPluck","cartesianCondition","limiting","String","enumToObject","Number","renameKeys","keysMap","obj","acc","key","findAndMerge","els","element","propName","addParam","name","func","args","mergeAndRestruct","wrapper"],"mappings":"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","sourcesContent":["import { always, append, assoc, chain, clone, converge, curry, filter, flatten, is, keys, length, map, mergeRight, objOf, of, omit, path, pick, pipe, pluck, prop, propEq, reduce, reject, slice, splitAt, transpose, values, when, xprod, zipObj, __ } from 'ramda';\nimport { ColumnType, ObjectLiteral, Option, OptionDate, OptionNumber, TypeLimiting } from '../react-app-env';\n// import {Maybe} from 'ramda-fantasy'\nconst RF = require('ramda-fantasy'),\n  Maybe = RF.Maybe,\n  Just    = Maybe.Just,\n  Nothing = Maybe.Nothing;\n// const seq = sequence(Maybe.of, [Maybe.Just(1), Maybe.Just(2), Maybe.Just(3)])\n// const lenFuncTest = lenFunc(\"string\")\n// lenFunc(\"asdfasf\")\n// export const multipledParts: any = (parts: any[][]) => parts.reduce(<any>xprod)\n//   .map(<any>flatten)\nimport {multipledParts} from 'ramda-combo'\nexport const sliceAndTranspose = curry((\n  columns: ColumnType<OptionNumber | OptionDate | Option>[], multipled: any[], equalsName: any\n) => pipe(\n  filter<any, any>(equalsName),\n  path([0, 'collect']),\n  converge(\n    append,\n    [\n      clone, pipe(\n        converge(\n          slice(0),\n          [length, always(multipled)]\n        ),\n        of\n      )\n    ]\n  ),\n  transpose\n)(columns))\n/**\n *   CartesianProduct Non using Ramda\n  const result = parts.reduce((\n    a, b\n  ) => a.reduce(\n    (\n      r, v\n    ) => r.concat(b.map(w => [].concat(\n      v, w\n    ))), []\n  ))\n */\n// TODO: REDUCE ~> one cycle\nexport const propFilterAndPluck = (\n  propNameEq: string, propValue: string, propPluck: string\n): any => pipe<any, any, any>(\n  reject(propEq(\n    propNameEq,\n    propValue\n  )),\n  pluck(propPluck)\n)\nexport const cartesianCondition: any = (\n  columns: ColumnType<OptionNumber | OptionDate | Option>[], limiting: TypeLimiting\n) => pipe<any, any, any, any, any>(\n  propFilterAndPluck(\n    'name',\n    limiting,\n    'collect'\n  ),\n  multipledParts,\n  when(\n    always(is(\n      String,\n      limiting\n    )),\n    sliceAndTranspose(\n      columns,\n      __,\n      propEq(\n        'name',\n        limiting\n      )\n    )\n  ),\n  map(pipe<any, any, any>(\n    flatten,\n    converge(\n      zipObj,\n      [\n        always(pluck(\n          'name',\n          columns\n        )), clone\n      ]\n    )\n  ))\n)(columns)\nexport const enumToObject: any = pipe<any, any, any, any>(\n  values,\n  converge(\n    splitAt,\n    [\n      pipe<any, any, any>(\n        filter(is(Number)),\n        length\n      ), clone\n    ]\n  ),\n  converge(\n    zipObj,\n    [prop<any>(0), prop<any>(1)]\n  )\n)\nexport const renameKeys: any = curry((\n  keysMap: ObjectLiteral, obj: ObjectLiteral\n) => reduce(\n  (\n    acc, key\n  ) => assoc(\n    keysMap[key] || key,\n    obj[key],\n    acc\n  ),\n  {},\n  keys(obj)\n))\nexport const findAndMerge = curry((\n  els: any[], element: ObjectLiteral, propName: string\n): any => map(<any>when(\n  propEq(\n    propName,\n    prop(\n      propName,\n      element\n    )\n  ),\n  mergeRight<any, any>(\n    __,\n    element\n  )\n))(els))\n\nexport const addParam = curry((\n  name: string, func: any, args: any[]\n) => chain(\n  assoc(name),\n  converge(\n    func,\n    args\n  )\n))\nexport const mergeAndRestruct = curry((\n  columns: string[], wrapper: string\n)=>converge(\n  mergeRight,\n  [\n    pick(columns), pipe(\n      omit(columns),\n      objOf(wrapper)\n    )\n  ]\n))"]},"metadata":{},"sourceType":"module"}