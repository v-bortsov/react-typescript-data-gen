{"ast":null,"code":"var toString = require('ramda/src/toString');\n\nvar curry = require('ramda/src/curry');\n\nvar util = require('./internal/util.js');\n\nfunction Maybe(x) {\n  return x == null ? _nothing : Maybe.Just(x);\n}\n\nMaybe.prototype['@@type'] = 'ramda-fantasy/Maybe';\n\nfunction Just(x) {\n  this.value = x;\n}\n\nutil.extend(Just, Maybe);\nJust.prototype.isJust = true;\nJust.prototype.isNothing = false;\n\nfunction Nothing() {}\n\nutil.extend(Nothing, Maybe);\nNothing.prototype.isNothing = true;\nNothing.prototype.isJust = false;\n\nvar _nothing = new Nothing();\n\nMaybe.Nothing = function () {\n  return _nothing;\n};\n\nMaybe.Just = function (x) {\n  return new Just(x);\n};\n\nMaybe.of = Maybe.Just;\nMaybe.prototype.of = Maybe.Just;\n\nMaybe.isJust = function (x) {\n  return x.isJust;\n};\n\nMaybe.isNothing = function (x) {\n  return x.isNothing;\n};\n\nMaybe.maybe = curry(function (nothingVal, justFn, m) {\n  return m.reduce(function (_, x) {\n    return justFn(x);\n  }, nothingVal);\n});\nMaybe.toMaybe = Maybe; // semigroup\n\nJust.prototype.concat = function (that) {\n  return that.isNothing ? this : this.of(this.value.concat(that.value));\n};\n\nNothing.prototype.concat = util.identity; // functor\n\nJust.prototype.map = function (f) {\n  return this.of(f(this.value));\n};\n\nNothing.prototype.map = util.returnThis; // apply\n// takes a Maybe that wraps a function (`app`) and applies its `map`\n// method to this Maybe's value, which must be a function.\n\nJust.prototype.ap = function (m) {\n  return m.map(this.value);\n};\n\nNothing.prototype.ap = util.returnThis; // applicative\n// `of` inherited from `Maybe`\n// chain\n//  f must be a function which returns a value\n//  f must return a value of the same Chain\n//  chain must return a value of the same Chain\n\nJust.prototype.chain = util.baseMap;\nNothing.prototype.chain = util.returnThis; //chainRec\n\nMaybe.chainRec = Maybe.prototype.chainRec = function (f, i) {\n  var res,\n      state = util.chainRecNext(i);\n\n  while (state.isNext) {\n    res = f(util.chainRecNext, util.chainRecDone, state.value);\n\n    if (Maybe.isNothing(res)) {\n      return res;\n    }\n\n    state = res.value;\n  }\n\n  return Maybe.Just(state.value);\n}; //\n\n\nJust.prototype.datatype = Just;\nNothing.prototype.datatype = Nothing; // monad\n// A value that implements the Monad specification must also implement the Applicative and Chain specifications.\n// see above.\n// equality method to enable testing\n\nJust.prototype.equals = util.getEquals(Just);\n\nNothing.prototype.equals = function (that) {\n  return that === _nothing;\n};\n\nMaybe.prototype.isNothing = function () {\n  return this === _nothing;\n};\n\nMaybe.prototype.isJust = function () {\n  return this instanceof Just;\n};\n\nJust.prototype.getOrElse = function () {\n  return this.value;\n};\n\nNothing.prototype.getOrElse = function (a) {\n  return a;\n};\n\nJust.prototype.reduce = function (f, x) {\n  return f(x, this.value);\n};\n\nNothing.prototype.reduce = function (f, x) {\n  return x;\n};\n\nJust.prototype.toString = function () {\n  return 'Maybe.Just(' + toString(this.value) + ')';\n};\n\nNothing.prototype.toString = function () {\n  return 'Maybe.Nothing()';\n};\n\nmodule.exports = Maybe;","map":{"version":3,"sources":["/home/noname001/react-typescript-data-gen/node_modules/ramda-fantasy/src/Maybe.js"],"names":["toString","require","curry","util","Maybe","x","_nothing","Just","prototype","value","extend","isJust","isNothing","Nothing","of","maybe","nothingVal","justFn","m","reduce","_","toMaybe","concat","that","identity","map","f","returnThis","ap","chain","baseMap","chainRec","i","res","state","chainRecNext","isNext","chainRecDone","datatype","equals","getEquals","getOrElse","a","module","exports"],"mappings":"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","sourcesContent":["var toString = require('ramda/src/toString');\nvar curry = require('ramda/src/curry');\n\nvar util = require('./internal/util.js');\n\nfunction Maybe(x) {\n  return x == null ? _nothing : Maybe.Just(x);\n}\n\nMaybe.prototype['@@type'] = 'ramda-fantasy/Maybe';\n\nfunction Just(x) {\n  this.value = x;\n}\nutil.extend(Just, Maybe);\n\nJust.prototype.isJust = true;\nJust.prototype.isNothing = false;\n\nfunction Nothing() {}\nutil.extend(Nothing, Maybe);\n\nNothing.prototype.isNothing = true;\nNothing.prototype.isJust = false;\n\nvar _nothing = new Nothing();\n\nMaybe.Nothing = function() {\n  return _nothing;\n};\n\nMaybe.Just = function(x) {\n  return new Just(x);\n};\n\nMaybe.of = Maybe.Just;\n\nMaybe.prototype.of = Maybe.Just;\n\nMaybe.isJust = function(x) {\n  return x.isJust;\n};\n\nMaybe.isNothing = function(x) {\n  return x.isNothing;\n};\n\nMaybe.maybe = curry(function(nothingVal, justFn, m) {\n  return m.reduce(function(_, x) {\n    return justFn(x);\n  }, nothingVal);\n});\n\nMaybe.toMaybe = Maybe;\n\n// semigroup\nJust.prototype.concat = function(that) {\n  return that.isNothing ? this : this.of(\n    this.value.concat(that.value)\n  );\n};\n\nNothing.prototype.concat = util.identity;\n\n// functor\nJust.prototype.map = function(f) {\n  return this.of(f(this.value));\n};\n\nNothing.prototype.map = util.returnThis;\n\n// apply\n// takes a Maybe that wraps a function (`app`) and applies its `map`\n// method to this Maybe's value, which must be a function.\nJust.prototype.ap = function(m) {\n  return m.map(this.value);\n};\n\nNothing.prototype.ap = util.returnThis;\n\n// applicative\n// `of` inherited from `Maybe`\n\n\n// chain\n//  f must be a function which returns a value\n//  f must return a value of the same Chain\n//  chain must return a value of the same Chain\nJust.prototype.chain = util.baseMap;\n\nNothing.prototype.chain = util.returnThis;\n\n\n//chainRec\nMaybe.chainRec = Maybe.prototype.chainRec = function(f, i) {\n  var res, state = util.chainRecNext(i);\n  while (state.isNext) {\n    res = f(util.chainRecNext, util.chainRecDone, state.value);\n    if (Maybe.isNothing(res)) {\n      return res;\n    }\n    state = res.value;\n  }\n  return Maybe.Just(state.value);\n};\n\n\n//\nJust.prototype.datatype = Just;\n\nNothing.prototype.datatype = Nothing;\n\n// monad\n// A value that implements the Monad specification must also implement the Applicative and Chain specifications.\n// see above.\n\n// equality method to enable testing\nJust.prototype.equals = util.getEquals(Just);\n\nNothing.prototype.equals = function(that) {\n  return that === _nothing;\n};\n\nMaybe.prototype.isNothing = function() {\n  return this === _nothing;\n};\n\nMaybe.prototype.isJust = function() {\n  return this instanceof Just;\n};\n\nJust.prototype.getOrElse = function() {\n  return this.value;\n};\n\nNothing.prototype.getOrElse = function(a) {\n  return a;\n};\n\nJust.prototype.reduce = function(f, x) {\n  return f(x, this.value);\n};\n\nNothing.prototype.reduce = function(f, x) {\n  return x;\n};\n\nJust.prototype.toString = function() {\n  return 'Maybe.Just(' + toString(this.value) + ')';\n};\n\nNothing.prototype.toString = function() {\n  return 'Maybe.Nothing()';\n};\n\nmodule.exports = Maybe;\n"]},"metadata":{},"sourceType":"script"}